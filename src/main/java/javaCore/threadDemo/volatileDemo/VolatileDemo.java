package javaCore.threadDemo.volatileDemo;

/**
 * Создадим один поток new Thread()и в него передаем лямбда выражение, в которм прописываем,
 * пока флаг не равен true то вы водить собщение System.out.println("still false")
 * Далее создаем другой поток, в котором будем при помощи все той же лямбды устанавливать флаг
 * в положение true.
 * И вот сдесь может произойти проблема, т.к. в современых компьютерах используется так называеммый
 * КЕШ то ядро процессора которое выполняет один из потоков может сохранить новое состояние флага
 * себе в КЕШ, в этом случае другое ядро выполн. другой поток не увидит изменнение данных, или
 * увидит когда ядро выгрузит из КЕШа данные в оперативную память. Поэтому Данные могут
 * проходить некоректную обработку. Для этих целей существует ключевое слово volatile- он говорит
 * о том что процессор не будет использовать свой КЕШ,а данные будут сразу отправляться в опер.пам.
 * конечно по времени это будет более длительный процесс, но тем не мениее даные будут целостные.
 * <p>
 * volatile работае только для примитивных типов и ссылок, т.е. мы можем увидеть
 * ссылка изменена или нет. Но если по этой ссылке идет сложный обьект то volatile не обезопашивает
 * нас от того что какое-то поле обьекта было изменено.
 */
public class VolatileDemo {
    private static volatile boolean flag = false;

    public static void main(String[] args) throws InterruptedException {
        Thread thread1 = new Thread(() -> {
            while (!flag) {
                System.out.println("still false");
            }
        });
        thread1.start();
        // Thread.sleep(2L);
        Thread thread2 = new Thread(() -> {
            flag = true;
            System.out.println("flag is set");

        });
        thread2.start();
        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
