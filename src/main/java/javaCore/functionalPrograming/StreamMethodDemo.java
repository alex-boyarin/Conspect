package javaCore.functionalPrograming;

public class StreamMethodDemo {
    public static void main(String[] args) {
        /**Stream<тип> of()-Создает поток из набора объектов.
         Stream<T> generate()-Генерирует поток по заданному правилу/
         Stream<T> concat()-Объединяет вместе несколько потоков
         Stream<T> filter()-Фильтрует данные: пропускает только данные, которые соответствуют заданному правилу
         Stream<T> distinct()-Удаляет дубликаты: не пропускает данные, которые уже были
         Stream<T> sorted()-Сортирует данные
         Stream<T> peek()-Выполняет действие над каждым данным
         Stream<T> limit(n)-Обрезает данные после достижения лимита
         Stream<T> skip(n)-Пропускает первые n данных
         Stream<R> map()-Преобразовывает данные из одного типа в другой
         Stream<R> flatMap()-Преобразовывает данные из одного типа в другой
         boolean anyMatch()-Проверяет, что среди данных потока есть хоть одно, которое соответствует заданному правилу
         boolean allMatch()-Проверяет, что все данные в потоке соответствуют заданному правилу
         boolean noneMatch()-Проверяет, что никакие данные в потоке не соответствуют заданному правилу
         Optional<T> findFirst()-Возвращает первый найденный элемент, который соответствует правилу
         Optional<T> findAny()-Возвращает любой элемент из потока, который соответствует правилу
         Optional<T> min()-Ищет минимальный элемент в потоке данных
         Optional<T> max()-Возвращает максимальный элемент в потоке данных
         long count()-Возвращает количество элементов в потоке данных
         R collect()-Вычитывает все данные из потока и возвращает их в виде коллекции
         */
    }
}
