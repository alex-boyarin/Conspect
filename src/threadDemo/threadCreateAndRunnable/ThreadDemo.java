package threadDemo.threadCreateAndRunnable;

/**
 * В java поддерживается обработка множества запросов одноременно. Это и естьмного поточность.
 * По сути это отдельный поток который обрабатывается в приложении.
 * Далее как получить этот поток который выполняет данную строчку? Все дело в том что мы можем
 * это сделать с помощью нашего класса Thread т.е. он так и называется и находится в пакете
 * java.lang, и мы можем в любой момент времени определить какой поток выполняет ту или иную строчку
 * в коде вызвав метод currentThread().getName() и взять у него имя потока getName(). Когда запустим
 * преложение мы увидим название текущего потока.
 * Ок, теперь как создавать другие потоки? Мы знаем что до этого мы писали преложения в одном потоке
 * но как их создать несколько, дело в том что таких способов существует всего 2:
 * 1-это создание экземпляра, унаследовавшись от нашего класса Thread.
 * 2-это реализовать интерфейс Runnable.
 */

public class ThreadDemo {
    /**
     * Начнем с первого для этого создадим свой thread-поток  назовем его SimpleThread
     */
    public static void main(String[] args) {
        /*т.к. наш поток SimpleThread ни чем не отличается от других классов, то он создается
        точно так же через new.*/
        SimpleExtendsThread simpleExtendsThread = new SimpleExtendsThread();// в java 1.9 появилось ключевое слово var
        //когда мы не хотим указывать название класса. Таким образом мы определяем тип переменой
        // на основании правой части. var используется только для локальных переменных.
        var runnableThread = new Thread(new SimpleImplementsRunnable(), "my name");//ОПИСАНИЕ ВНИЗУ СТРАНИЦЫ !!!
        var lambdaThread = new Thread(() -> System.out.println("Hello from lambda: " + Thread.currentThread().getName()));

        /** Но мы только создали его new SimpleExtendsThread(), т.е. у нас есть обьект нашего потока,
         *  но тем не менее нам нужно как-то его запустить. И для того чтобы запустить этот поток нам неодходимо
         *  не вызвать метод run(), потому-что если мы вызовем метод run() то он будет вызван у нашего main()
         *  И для того чтобы наш run() выполнялся в другом потоке нужно вызвать функцию start(), вот только
         *  после этого приложение создаст новый поток, и в новом потоке вызовет метод run()*/
        simpleExtendsThread.start();
        runnableThread.start();
        lambdaThread.start();
        /**
         * Дело в том что если мы запустип несколько раз наш class ThreadDemo, то нет гарантии что наша
         * функция main() или метод run() вызовется раньше. Если мы хоти м чтобы поток simpleThread гарантированно
         * был выполнен первым нам нужно у него вызвать метод join()
         */
        try {
            simpleExtendsThread.join();
            runnableThread.join();
            lambdaThread.join();
        } catch (InterruptedException e) {//нужно обрабатывать исключения. После того как поток начал свое
            e.printStackTrace();//выполнение его невозможно остановить, все что мы можем сделать это
            //вызвать метод interrupt(), говорящий потоку как только сможешь остановиться то остановись.
        }
        /** Что сдесь происходит, в точке 38 нашего главного потока main(),
         мы вызываем у другого потока метод join()-(присоединиться) означающий
         что поток вызвавший этот метод будет ждать до тех пор, пока обьект у которого был вызван
         этот метод не закончит своего выполнения. Следовательно пока simpleThread не закончит
         своего выполнения, приложение не перейдет на следующую точку программы
         */
        System.out.println(Thread.currentThread().getName());

    }
}
/**
 * Но т.к. мы уже видели что у SimpleRunnable кроме метода run() ничего нет, т.е. мы не можем сделать
 * start() у него, следовательно SimpleRunnable это просто действие у нашего потока, поэтому
 * он не может самостоятельно существовать без класса Thread. Поэтому чтобы запустить наш поток
 * и выполнить то действие которое мы описали в SimpleRunnable нам нужно создать класс Thread.
 * Мы пишем new Thread() и смотрим на конструкторы которые у него есть,
 * и как видно один из конструкторов принимает Runnable, так же есть конструктор который прринимает
 * просто название потока, так же есть констр. принимающий Runnable, и название.
 * Далее чтобы запустить наш Thread  мы можем использовать лямда выражения.
 * Или оборачиваем в такую конструкцию Thread runnableThread = new Thread(new SimpleRunnable());
 * <p>
 * Какой из вариантов предпочителен? Естественно так как мы используем интерфейсы а не классы,
 * то у нас появляется большая гибкость и мы можем наследоваться от какого нибудь другого класса
 * но тем не менее у нас остается возможнось использовать обьект нашего класса который реализует
 * интерфейс Runnable как поток просто передав его в обьект класса Thread.
 */
/**
 * Какой из вариантов предпочителен? Естественно так как мы используем интерфейсы а не классы,
 * то у нас появляется большая гибкость и мы можем наследоваться от какого нибудь другого класса
 * но тем не менее у нас остается возможнось использовать обьект нашего класса который реализует
 * интерфейс Runnable как поток просто передав его в обьект класса Thread.
 */